## 性能优化

### 一. 开发优化

#### 1. CSS优化

优先使用CSS transform和opacity来完成动画，合理使用will-change来告知浏览器提前进行优化，减少使用JavaScript动画，避免浏览器回流。在Vue和React中，实现动画的组件也是使用CSS动画，通过动态添加类名来实现。

#### 2. 防抖和节流

对于频繁触发的事件（输入框，滚动事件）使用防抖和节流，减少触发的频率。

#### 3. 避免内存泄漏

合理使用闭包，及时清理定时器，事件监听器，websocket连接（组件销毁时）等，避免内存泄漏。

#### 4. 执行大量任务

- 将复杂繁重的任务放到Web Worker线程中执行，避免阻塞主线程
- 将任务分批次执行，使用requestAnimationFrame(cb)让浏览器在渲染完（每秒60帧）之后的空闲时间执行任务，或使用setTimeout等事件循环机制将任务进行异步调度

#### 5. 框架优化

#### 5.1 Vue

**5.1.1 避免组件不必要的渲染**

- 合理使用v-if和v-show，当一个组件需要被频繁切换时使用v-show，v-show通过更改CSS display属性避免组件的频繁销毁和创建
- 合理使用keep-alive缓存组件，keep-alive内部通过Map和Set对组件进行缓存
- 使用key来确定组件的唯一性，尽可能地复用组件，提高Diff算法的性能，避免不必要的Diff
- 状态下沉到子组件中，避免父组件不必要的更新

**5.1.2 避免重复的大量计算**

- 合理使用computed缓存计算结果，避免重复计算

#### 5.2 React

### 二. 打包优化

### 三. 部署优化

#### 1. 资源加载优化

- 图片懒加载，只加载可视区域的图片

```javascript
// 1. 使用HTML5的图片懒加载属性
<img src="image.jpg" alt="示例图片" loading="lazy" />
// 2. 使用Intersection Observer监测是否进入可视区域，将data-src属性赋值给src属性
<img data-src="image.jpg" alt="示例图片" class="lazy" />
<img data-src="image2.jpg" alt="示例图片" class="lazy" />

<script>
  // 获取所有需要懒加载的图片
  const lazyImages = document.querySelectorAll('img.lazy');

  // 创建 Intersection Observer
  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        // 将 data-src 的值赋给 src 属性
        img.src = img.dataset.src;
        img.classList.remove('lazy');
        observer.unobserve(img); // 停止观察已加载的图片
      }
    });
  });

  // 观察每个图片
  lazyImages.forEach(image => observer.observe(image));
</script>

```

- 缩略图，对图片进行压缩，首页展示缩略图，详情页展示高清图
- 压缩图片格式，使用webp等轻量级的格式减少图片体积
- 精灵图，将多张图片合并为一张图片，减少HTTP请求数
- 预加载或预获取，preload和prefetch，区别在于preload会并行加载，prefetch在空闲时再加载
- 异步加载脚本，async和defer，减少脚本对DOM构建的阻塞
- 使用CDN优化，加快静态资源的传输速度

CDN原理，内容分发网络，由多个服务器节点组成，客户端请求时可去最近的节点请求，加快传输速度

1. DNS解析返回最佳接入IP
2. 向最近的节点请求资源
3. 若缓存命中直接返回，无缓存则回到源站请求，并在下一次进行缓存

![](C:\Users\ryli\Desktop\interview\images\CDN原理.png)

- HTTP缓存，使用HTTP缓存图片

1. 强缓存，设置HTTP头Cache-Control：max-age=xxx，immutable，下次请求直接从浏览器缓存返回响应

​	   缓存更新：设置文件哈希，更新时修改文件哈希，浏览器看到新的资源会重新请求，或者采用协商缓存

2. 协商缓存，设置HTTP头Cache-Control：no-cache或max-age=0，浏览器可以使用缓存，但需要去服务器先校验，如果返回304 Not Modified则缓存命中

​       请求头If-None-Match："hash"配合响应头ETag：“hash”

​	   请求头If-Modified-Since：“time”配合响 应头Last-Modified：”time“使用

​       缓存来源：小文件，频繁加载的资源可以缓存到内存中，较大的文件，长期存储的文件可以缓存到磁盘中

- Service Worker离线缓存，可以配置Service Worker进行离线缓存，即使没有网络也能加载，配合manifest.json使用PWA