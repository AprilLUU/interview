## vue3-ts-cms

1.  项目规范

   husky git hooks 安装husky 执行husky install 添加husky安装脚本 npm install之前先执行husky install

   拦截git commit，执行npm run lint，

   检验commit-msg, 配置commit-lint

   commitizen git commit -m 

   代码规范：editorconfig prettier eslint 

   使用空格缩进，一个tab2个空格，字符长度，双引号，不添加分号，不添加尾逗号，去除行首空格，文件末尾插入新行，换行类型。

   2.  路由注册问题

      动态注册路由，请求菜单数据返回之后，或者store数据初始化之后根据菜单去匹配路由进行注册。

      刷新页面报404错误，与以下两行代码执行时机以及vuerouter内部执行时机有关。

      如何解决问题，先在路由守卫里打印了所有的路由对象，发现正确，但是不能正确跳转，然后打印了to对象，发现匹配到的路由对象组件是notFound，然后就尝试了以下调转两行代码的执行顺序，先动态注册完所有路由，再去调用app.use(router),就能正确匹配组件，网上搜一下解决方案，发现跟vuerouter的执行时机有关。先执行app.use(router),先去执行router.install函数，会获取当前path去匹配路由，匹配到notFound，之后再执行setupStore()动态注册路由，但是之前路径已经匹配到notFound，所以就会跳转到notFound页面。路由守卫是每次跳转之前才会执行的回调函数，因此，可以获取到正确的路由对象。

      app.use(router) setupStore()

      setupStore() app.use(router)

      3. element-plus自动导入问题（以服务的方式调用时无法自动导入CSS，去github查找对应的解决方案，发现自动导入不支持这种方式，需要手动导入CSS文件）
      
      4. 权限控制，准备好所有路由对象，利用webapck的require.context函数去加载所有对象并根据用户菜单进行匹配，动态添加路由，并找到当前用户的第一个路由菜单，当用户已登录并且token未过期，跳转到第一个菜单。
      
      5. 按钮权限控制，拿到服务器返回的所有的权限对象，放到store中，根据不同页面的不同按钮操作去匹配是否具有权限，决定是否显示按钮以及发送网络请求。
      
      6. 页面刷新，设置menu的default-index，根据当前路径去匹配到对应的路由，并拿到index设置给menu组件。
      
   7. 监听浏览器窗口变化，决定是否折叠菜单，并进行防抖处理，多组件通信，由子组件发出事件并携带参数值，父组件监听事件拿到参数值设置给另一个子组件。
      
   8. 格式化显示菜单内容，根据服务器的数据去匹配菜单对应的内容进行显示。菜单页面为了显示上次菜单名称，根据服务器返回的parentID去匹配上级菜单名称，以及在新建菜单时选择显示对应的菜单名称，根据菜单去匹配相应的页面配置传递给基础组件进行显示。
      
      9. 角色界面对话框对对应的数据进行回显，拿到菜单树中的所有叶子节点的key，选择叶子节点，对应的父节点也会选择上，设置给eltree组件。调用eltree的设置key的方法时，由于函数调用时机是在当前页面按钮点击时，弹出对话框，此时eltree组件还没有跟ref绑定上，无法拿到eltree组件，解决方法，使用nexttick()。
      
      10. 对Axios的封装，对AxiosRequestConfig类型进行扩展，应用请求响应拦截器和showLoading，单个实例，单个请求，所有实例的请求响应拦截器，请求拦截器，携带token显示Loading，响应拦截，对服务器的数据进行过滤，拿到服务器返回数据的部分，由于全局响应拦截器对数据进行了过滤，类型不再是AxiosResponse类型，在应用单个请求的响应拦截时报错，解决方案，调用请求函数时传入一个泛型，决定axios.request<any,  T>决定返回的类型。
      
      11. vuex store在使用module时没有类型提示，定义联合类型，IRootState && IRootWithModuleState，然后对Vuex useStore进行包裹，传入泛型，决定返回值的类型。useStore：Store<IModuleState>
      
      12. 页面按钮操作数据之后，重新发送网络请求，需要携带当前页面的搜索数据，将页面的数据保存在vuex Store中统一进行发送网络请求。用户退出登录，但是没有退出系统，store中的数据还存在，再次进入系统时会显示对应的数据，退出登录后清除store中的数据。
      
      13. ts报没有string的索引签名，定义类型 [key: string | symbol]: T
      
      14. 封装组件思路，遍历传递过来的数据生成，预留插槽可自定义，预留属性，暴露方法，发出事件。
      
          表格组件，属性，决定是否显示表尾分页器，是否显示选择列，索引列等，以及传递一些自定义的配置，选择当前列，点击按钮时需要拿到数据，发出事件传递数据，父组件监听即可拿到数据。适配不不同页面的差异，传递插槽名，组件内部预留动态插槽，可由外部自定义。
   
   核心是用Vue来完成系统的前端开发。现有的前端开发都是一种组件化开发的模式，基于这种开发模式，我将代码划分为6层来实现和管理，分别是基础组件层，公用组件层，页面组件层，路由管理层，数据共享层，网络请求层，其中基础组件是一些通用性的组件，目的是提高代码的复用性，可以为其他项目所使用；公用组件是对多个页面的相似部分的抽取；页面组件是每一个页面的代码实现；数据共享是组件所共享的数据的统一管理；路由管理是根据路由即浏览器的URL来渲染不同的组件；网络请求是负责向服务器发送网络请求来获取数据。在开发过程中我才用了git来进行代码的版本管理，然后系统实现的一些主要功能有用户的登录注册，用户的权限控制，用户的信息管理，商品的信息管理，数据导出，商品信息的可视化展示。
   
   基础组件，例如在页面中用到了表格，一般的表格都会有表头，表尾分页器等信息，基础组件中会包含完整的表格，在使用组件时可以传递一些数据来自定义表格的内容，比如是否显示表头，是否增加一些操作按钮，是否显示表尾分页器等等。
   
   公用组件，公用组件会用到基础组件比如表格组件，由于我在系统中每一个页面都会用到同样的表格，因此将每一个页面中表格封装成一个公用组件，里面封装了表格的页面结构以及对应的功能逻辑，每个页面只要使用这个组件即可不用写重复的代码。
   
   页面组件，使用了公用组件，同时加入每一个页面中特有的一些东西，比如一个页面可能有头部的搜索信息，另一个页面没有。
   
   数据共享，在前端也称为状态管理，就是管理多个组件之间共享的数据，比如用户的操作权限，用户的登录令牌等
   
   路由管理，用Vue开发的网站很多都是属于单页面应用，然后根据浏览器URL的改变来渲染不同的组件展示不同的页面，同时也会处理一些逻辑，比如用户在跳转时是否已登录，未登录则跳转到登录页面（判断用户的登录令牌是否存在浏览器的本地存储中）
   
   网络请求，负责发送网络请求到服务器来获取数据，同时向数据共享层提供数据，组件从数据共享层中取出数据来进行展示。
   
   大致逻辑是，公用组件使用了基础组件，页面组件使用了公用组件，网络请求层将请求回来的数据提供给数据共享层，页面组件从数据共享层中拿出数据进行展示。