## 浏览器原理

![](./images/浏览器渲染原理.png)

1. 解析HTML，构建DOM Tree
2. 遇到link元素或者@import，下载CSS文件并解析，生成对应的规则树CSSOM，这个过程并不会阻塞DOM Tree的构建
3. 遇到script元素，下载JS文件并执行，除非是异步脚本，否则会阻塞DOM Tree的构建
4. 构建Render Tree，Render Tree需要DOM Tree和CSSOM，因此CSS解析会阻塞Render Tree的构建

- Render Tree与DOM Tree并非一一对应，display为none的节点不会出现在Render Tree

5. 在Render Tree上进行布局，计算所有节点的宽高，位置等几何信息

6. 浏览器将对应的元素绘制到屏幕上

#### 1. 回流和重绘

第一次确定节点的大小和位置，则为布局，之后由于大小，位置修改影响布局，需要重新计算节点的几何信息，则为回流

- getComputedStyle获取尺寸，位置信息
- 窗口resize
- 修改宽度，高度等
- 改变DOM结构，添加或移除节点

重绘是对元素的重新绘制，回流一定会引起重绘

- 修改背景色等，不会进行回流，但会引起重绘

回流影响性能，需要避免回流，Vue，React等框架引入虚拟DOM进行Diff的目的就是为了减少DOM操作，减少回流

- 频繁发生变化，影响布局的元素可以单独创建合成层进行渲染，不影响其他元素
- 避免频繁操作DOM
- 避免使用getComputedStyle

#### 2. 合成层

合成层是浏览器的一种优化手段，默认情况下，标准流中所有元素都是绘制到单独的一个图层中，一些特定的属性会创建新的合成层，而且可以利用GPU进行加速

- 绝对定位等
- animation或者transition设置了transform，opacity
- 3D transformers
- will-change告诉浏览器哪些属性将要发生变化，让浏览器提前进行优化

合理利用合成层可以提高性能，但不应该滥用，因为是以内存为代价

#### 3. V8引擎垃圾回收

- **引用计数**，给对象添加引用计数，引用为0时，则视为垃圾，进行回收，解决不了循环引用的问题
- **标记清除**，从根对象出发，找到所有引用到的对象，没有引用到的对象视为不可达，进行内存回收，可以解决循环引用

#### 4. JavaScript执行原理

1. 创建全局执行上下文GEC，压入执行上下文栈ECS，创建全局对象GO，并进行变量提升（未初始化）
2. 执行全局代码，初始化对应的变量
3. 遇到函数执行，创建函数执行上下文FEC，压入执行上下文栈ECS，创建激活对象AO
4. 执行函数体代码，初始化对应的变量

- **GO**，全局对象，也为全局作用域，存放全局变量，包括全局代码中定义的变量以及Math，setTimeout等全局函数，浏览器环境下是window，node环境下是global
- **AO**，激活对象，对应函数作用域

#### 5. 作用域和作用域链

ES6之后有了块级作用域，总共有三种作用域

- **全局作用域GO**
- **函数作用域AO**
- **块级作用域**

每一个执行上下文都会关联一个作用域链，用于变量查找求值，作用域在定义时就已经关联，例如

```javascript
let name = "Global"

function foo() {
	let name = "foo"
	function bar() {
		let name = "bar"
	}
}

foo()
```

执行bar函数时会形成 barAO -> fooAO -> GO

#### 6. 闭包

闭包的形成在于内部函数引用了外部作用域的变量。闭包可以让一个变量在函数执行完之后不会被销毁，因此需要注意内存泄漏的问题，在不需要使用的时候需要及时释放。闭包的应用场景有很多，比如防抖节流函数。

#### 7. 内存泄漏

总结一个点，就是在不需要使用的时候需要清理引用，从而让垃圾回收器能够及时回收内存，使用WeakMap，WeakSet等，可以扩展到Vue的响应式原理

- **闭包**，闭包维持了外部作用域的引用，在不需要使用时需要及时释放
- **定时器，事件监听器**在不需要使用时需要及时销毁
